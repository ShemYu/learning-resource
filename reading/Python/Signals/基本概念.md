# Whats Signals, Dispatch

Signal 如同其名是一種訊號的概念，用專業術語來解釋的話:

> a `receiver` (or `listener`) may `subscribe` (or `listen`) to the `signal` of a `sender`. When the `sender` sends (or `broadcasts`) a `signal`, the `receiver` is called
> 接收對象會持續監聽到來自特定對象(Sender)的訊號；當該對象發出(廣播出)訊號的同時，接收對象就會被呼叫。

簡單來說，便是藉由代碼連接 receiver, sender，針對特定方法進行 callback。

> # Dispatch: signal broadcasting in python
> Signals are useful when two otherwise unrelated pieces of code depend on each other. The general pattern is that a receiver (or listener) may subscribe (or listen) to the signal of a sender. When the sender sends (or broadcasts) a signal, the receiver is called.

PyPubSub 文件當中提及了一些使用 signal pattern 的優點:

- Sender/Receiver 不需要互相 import 對方
- Sender 也無須控管:
  - 誰會拿到 Signal
  - Receiver 會做什麼
  - 甚至是否有 Receiver 的存在
- 反之 Receiver 也是

# Lazy Evaluation Pattern

Lazy Evaluation Pattern 是一個經典 usecase，倘若有一個變量 x，且有一個相依 function F，當 x 發生變化時，倘若 F, x 是定義在完全不同的 module 當中，在 x 發生變化時，要取得 F(x) 的成本就非常高了。

你可能會 import module，在每次 x 可能變動時做檢查，發生變動時觸發 F 做更動，你可能完成了一個邏輯達到 `x 更新時自動執行 F(x)`，但倘若今天有個新的 function F2 要達到同樣的目的，開發成本與執行成本就倍數增大。

這就是為什麼 Signal 的概念出現；倘若將物件的責任獨立開，x 變動時只要發出 Signal，而 Receiver 的責任便是接收到 Signal 時便執行，那上述需求就簡化許多。

初次開發我們只需幫 x 的物件裝上發信器(dispatcher)，並將接收器指定接收特定 `signal`。