# 底線家族的秘密 
菜鳥時期，在開發前 trace code 階段，初次接觸到別人程式時，就發現類別相關語法，運用了大量的 `_`，當時啥都不懂整個霧煞煞，稍微查了一下才發現 Python 當中**底線家族**是十分重要的變數命名規則之一。

### Medium
> ### 原文 [Python Tricks — 底線家族的秘密](https://medium.com/python-language/python-tricks-%E5%BA%95%E7%B7%9A%E5%AE%B6%E6%97%8F%E7%9A%84%E7%A7%98%E5%AF%86-d84a2ce9cde6)

第一篇我閱讀了這篇 Medium，是由主管轉帖給我，讓我好好理解 Python 底線的運用，其中介紹了許多關於底線的運用情境、規則，是否有特殊意涵等，整理為以下幾項:

## 單底線 (Undersocre, _)
- 顧名思義**就是一個底線**，其他啥都沒
- Shell 環境下: **最後一次的執行結果**
- 當不需要某回傳值，以 `_` 表示就**無需儲存為變數，占用記憶體空間**

## 前底線 (_single_leading_underscore)
- 代表著 C++, JAVE 當中的 **Private**
> ## Python.org   
> “Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member)
- 僅是一種慣例，並**不強制隱藏**，因此仍能從外部進行 CRUD
- `import *` 會被忽略，但仍可強制 import，或透過 `__all__`(後續介紹) 定義可 import

## 後底線 (single_trailing_underscore_)
- 如果你把語言保留關鍵字(Keyword) 作為變數名稱使用，則須加上此種底線
- 非強制性，僅為一種命名規則或代碼風格建議

## 前雙底線 (__double_leading_underscore)
- 又稱為 **dunder**
- 為直譯器為**避免發生衝突**的命名方式，此種變數命名於類別當中，便自動直譯為 `_Class__varName` 的形式

## 前後雙底線 (__double_leading_and_trailing_underscore__)
- 保留**特殊用途**的 function name
- 可依據用途，供使用者作**複寫**，例如初始化物件時的 `__init__`
> ## Python.org
> `__double_leading_and_trailing_underscore__`: “magic” objects or attributes that live in user-controlled namespaces. E.g. `__init__`, `__import__` or `__file__`. Never invent such names; only use them as documented
- 又稱為 **Magic method**
# Magic method of Python

Magic method 指的是 Pyhton 為類別預定義的一些常用方法，例如定義類別的字串形式、實作時執行的方法、運算單元處理的方法等。

```python
class Example():
    def __init__(self):
        # 實作時觸發
    def __str__(self):
        # 字串形式
        return "Str type of class"
    def __add__(self, value):
        return self.A + value
```
---
## `__init__` 及 `__new__` 差別是什麼
其中最常使用的就是 `__init__`，實作 class 時會觸發的方法。    
雖然並非必須使用，但往往會遇到實作時需要處裡的類別，例如從生日計算年齡、從體重身高推算 BMI，甚至給定資料路徑，初始化先 loading 資料進物件當中，在依據使用者需求作客製化處理等。

```python
class human():
    def __init__(self, birth):
        self.age = time.today().year - self.birth.year
        self.birthday = birth
```
    
跟 `__init__` 十分相近的則是 `__new__`，不同的是 init 是在類別實作成物件時觸發，而 new 是在實作類別本身時就會觸發，也因此他的引數不是代表該實作**物件**本身的 `self`，而是代表**類別**本身的 `cls`。

```python
class human():
    def __new__(cls, name, age):
        print("Do when you new a `class`.")
        return super(human, cls).__new__(cls, name, age)
```

在以下文章當中有詳細關於 `__init__`, `__new__` 的調用邏輯，可供參考。    
> ## [Python 中的 `__init__` 和 `__new__`](https://www.zlovezl.cn/articles/__init__-and__new__-in-python/)
> `__init__` 和 `__new__` 最主要的区别在于：
> - `__init__` 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。
> - `__new__` 通常用于控制生成一个新实例的过程。它是类级别的方法。

在 Python 的官方文件當中，`__new__` 被說明為以下兩種用途:
- 當你在繼承一些無法複寫的類別時，可以使用 `__new__` 來做一種自定義
- 實作自定義之 `metaclass`

---